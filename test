                                                                                  ###########;m;        ###########;m;
                                                                                 #  #######  #;m;      # ###########;m;
  ##########;m;      #; ###;  #####;m;      ##########;m;     ###;m;    ###;m;   # #;m;    # #;m;      # #;m;
 # ######## #;m;     ## ## #;# ##  #;m;    # ######## #;m;     # #;m;  # #;m;    # #;m;    # #;m;      # #;m;
# #;m;     # #;m;    # #; # # #; # #;m;   # #;m;     # #;m;     # #;m;# #;m;     # #;m;    # #;m;      # #########;m;
#  ######## #;m;     # #;  # #;  # #;m;   #  ######## #;m;       # ### #;m;      # #;m;    # #;m;       ######### #;m;
# ##########;m;      # #;  # #;  # #;m;   # ##########;m;        # ### #;m;      # #;m;    # #;m;                # #;m;
# #;m;               # #;  # #;  # #;m;   # #;m;                # #;m;# #;m;     # #;m;    # #;m;                # #;m;
 # ########## #;m;   # #;  # #;  # #;m;    # ########## #;m;   # #;m;  # #;m;    #  #######  #;m;      ########### #;m;
  ###########;m;     # #;  # #;  # #;m;     ###########;m;    ###;m;    ###;m;    ###########;m;        ##########;m;


der clear command geht nicht richtig:

```c
FHDR(cmd_clear)
{
    u32 color = CONSOLESCREEN_BG_COLOR;
    // parse color argument if provided
    if (*s != '\0') {
        // simple color name parsing
        const char *p = s;
        while (*p == ' ') p++;
        if (*p == 'b' && *(p+1) == 'l' && *(p+2) == 'a' && *(p+3) == 'c' && *(p+4) == 'k') {
            color = GFX_BLACK;
        } else if (*p == 'w' && *(p+1) == 'h' && *(p+2) == 'i' && *(p+3) == 't' && *(p+4) == 'e') {
            color = GFX_WHITE;
        } else if (*p == 'r' && *(p+1) == 'e' && *(p+2) == 'd') {
            color = GFX_RED;
        } else if (*p == 'g' && *(p+1) == 'r' && *(p+2) == 'e' && *(p+3) == 'e' && *(p+4) == 'n') {
            color = GFX_GREEN;
        } else if (*p == 'b' && *(p+1) == 'l' && *(p+2) == 'u' && *(p+3) == 'e') {
            color = GFX_BLUE;
        } else if (*p == 'c' && *(p+1) == 'y' && *(p+2) == 'a' && *(p+3) == 'n') {
            color = GFX_CYAN;
        } else if (*p == 'y' && *(p+1) == 'e' && *(p+2) == 'l' && *(p+3) == 'l' && *(p+4) == 'o' && *(p+5) == 'w') {
            color = GFX_YELLOW;
        } else if (*p == 'p' && *(p+1) == 'u' && *(p+2) == 'r' && *(p+3) == 'p' && *(p+4) == 'l' && *(p+5) == 'e') {
            color = GFX_PURPLE;
        }
    }
    shell_clear_screen(color);
    banner_force_update();
}
```


egal was man nach clear eingibt die farbe kommt nicht und selbst nach dem scrolling passiert nichts behebe das bitte

auserdem mach die identifizierung von commands und input und so in parser.c und füge dan ein smartes command chaining hinzu also zb help && dofetch dazu noch das der & character komisch aussieht verbessere den und füge support für die arrow keys hinzu aber KEIN history hinzufügen
auserdem wenn du shell redraw input brauchst mach das in shell_screen.c
und ich will kein parser.h das soll wenn dan alles in console.h sein

auserdem wie du auf dem bild siehst die erste linie ist etwas weiter links als die anderen ich will das überall der gleiche abstand von x ist also von der linken seite
und zwar exact 0,0

auserdem hat noch jemand auf english gefragt ob ich das machen kann:
well defined printf in serial.c, print_ptr doesnt work, also can you add u64 support, general, if it 32 then 32,
kannst du das auch für mich erledigen?
